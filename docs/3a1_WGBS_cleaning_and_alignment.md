---
layout: default
title: Lesson 1 - WGBS raw data cleaning and alignment
nav_order: 1
parent: 3. Tutorial
description: A comprehensive guide to understanding epigenetics.
---
<!--
You can select the color-scheme for the tutorial: <button class="btn js-toggle-dark-mode">Preview dark color scheme</button>

<script>
const toggleDarkMode = document.querySelector('.js-toggle-dark-mode');

jtd.addEvent(toggleDarkMode, 'click', function(){
  if (jtd.getTheme() === 'dark') {
    jtd.setTheme('light');
    toggleDarkMode.textContent = 'Preview dark color scheme';
  } else {
    jtd.setTheme('dark');
    toggleDarkMode.textContent = 'Return to the light side';
  }
});
</script>
-->

{: .important-title }
> Aim
>
> During this tutorial we will analyse Illumina Whole Genome Bisulphite Sequencing (WGBS) data, which is a type of sequencing data that is used to study DNA methylation. We will learn how to clean and align the raw data to prepare it for downstream analysis. This will involve understanding the different types of data that are generated by the sequencing process, how to handle missing data, and how to use bioinformatics tools to align the data to the reference genome.
> 


<details open markdown="block">
  <summary>
    Table of contents
  </summary>
  {: .text-delta }
- TOC
{:toc}
</details>

<!--
---

- [Quality control](#1-First-step-check-fastq-quality-using-fastqc-software)
    - [FastQC](#fasta)
- [Trimming](#2-second-step-perform-trimming-of-raw-data)
    - [Trimgalore](https://gabbo89.github.io/EEA2024/docs/2a_TrimGalore_manual.html)
- [Alignment](#3-Alignment-of-fastq-files)
    - [Bismark](https://gabbo89.github.io/EEA2024/docs/2a_Bismark_manual.html)

-->

---

# 1. Quality control and trimming of raw fastq files
Sequencing raw data are divided in read1 and read2 and store in `fastq` format. Fastq files are compressed in `gzip` format (*.fastq.gz)

We need to check the quality of the raw data in order to be sure that sequencing worked!

We will use FastQC software to verify if raw data quality is appropriate and thus planning the quality trimming.
Fastqc is available both as graphical and textual interface (we will use the textual).  
---

## a. Check fastq quality using fastqc software 

### Activate the conda environment
{: .no_toc }
```bash
conda activate epigenomics
```

### Test if fastqc is working
{: .no_toc }
```bash
fastqc --help
```
{: .success-title }
> STDOUT
>            FastQC - A high throughput sequence QC analysis tool
>
>SYNOPSIS
>
>        fastqc seqfile1 seqfile2 .. seqfileN
>
>    fastqc [-o output dir] [--(no)extract] [-f fastq|bam|sam]
>           [-c contaminant file] seqfile1 .. seqfileN
>

### Copy the raw data from the folder to our working directory
{: .no_toc }
```bash
cp ... /data2/student_space/st24_01_folder/epigenomics/wgbs
```
<!--
cd /projects/novabreed/share/gmagris/collaboration/lezioni/2024/EEA/wgbs/teaching_dataset
-->

### Run Fastqc 
{: .no_toc }
In order to store the output of fastqc in a subfolder, we need to create first the directory

```bash
mkdir -p rkatsiteli.leaves
```

```bash
fastqc rkatsiteli.leaves.R1.fastq.gz rkatsiteli.leaves.R2.fastq.gz -o rkatsiteli.leaves
```

#### Check the output files obtained
{: .no_toc }
The output of fastqc is a html file with different plots. It is possible to open it with a browser. Browse to the location where the files are located. You should see a folder with the name of the sample and inside it a html file with the name. Open it with a browser. 

You should see different plot, for example:


| **Per base sequence quality** | **Per base sequence content** |
|:--------:|:---:|
|  ![seq_qual]({{/assets/images/per_base_sequence_quality.png | relative_url }})  | ![seq_cont]({{/assets/images/per_base_sequence_content.png | relative_url }})  |


 The most important are the following:
- **Per base sequence quality**: This plot shows the quality of each base in the sequence. The quality is measured in Phred score. The higher the score, the better the quality. The average quality of the bases should be above 20. If the average quality is below 20, it means that the sequencing was not good and the data should be discarded.
- **Per sequence quality scores**: This plot shows the quality of each sequence. The quality is measured in Phred score. The higher the score, the better the quality. The average quality of the sequences should be above 20. If the average quality is below 20, it means that the sequencing was not good and the data should be discarded.
- **Per base sequence content**: This plot shows the frequency of each base in the sequence. The frequency of each base should be around 25%. If the frequency of a base is higher or lower than 25%, it means that there is a bias in the sequencing and the data should be discarded.
- **Per sequence GC content**: This plot shows the GC content of each sequence.
- **Sequence length distribution**: This plot shows the length of each sequence. The length of the sequences should be around the same size. 
- **Sequence duplication levels**: This plot shows the level of duplication in the sequences. The level of duplication should be low (around 1). If the level of duplication is high, it means that the data may have some contamination and thus further filter may be required.
- **Overrepresented sequences**: This plot shows the sequences that are overrepresented in the data. If there are sequences that are overrepresented, it means that there is a bias in the sequencing and the data should be discarded.

{: .note }
It is important to look at the different plots to evaluate the quality of the data. If the quality of the data is good, it can be used for further analysis. If the quality of the data is not good, we have different options.

{: .note }
The quality of the data can be improved by trimming the data. Trimming removes low quality bases from the data. Trimming can be done with software such as Trim Galore.

{: .note }
 If the data is not good quality, it should be discarded. 


Refer to the powerpoint presentation for additional informations.  

----

## b. Perform trimming of raw data 

Once the quality is evaluated we can procede by removing low quality bases from the fastq files.
Native reads will be subject to quality and adapter trimming before the alignment. Clipping of additional bases at 5' and/or 3' end may deemed necessary in certain circumstances.

We will use TrimGalore to remove adapter and low quality data from fastq file [TrimGalore short manual][trimgalore short manual]{: .btn } and [TrimGalore on Github][trimgalore_github]{: .btn }

We will use it with a reduced set of options, but remember that there are many options available that can be used to customize the trimming process.

####The most important options are:

- `--path_to_cutadapt cutadapt` trimming software loading
- `--phred33`  Phred quality scores (DEFAULT)
- `--illumina` for Illumina adapters
- `--paired` for paired sequences
<!--- `--trim1` to elude the software that discards overlapping reads-->

This extra options can be used to trim the reads both at 5' and/or 3' end.

- `--clip_R1 20` cut 20 nt in R1 (5’)
- `--clip_R2 6` cut 6 nt in R2 (5’)
- `--three_prime_clip_R1 4`  cut 4 additional nt in 3’ because adapters clipping leads to residual low-quality bases
- `--three_prime_clip_R2 4`  cut 4 additional nt in 3’ because adapters clipping leads to residual low-quality bases

```bash
trim_galore \
--path_to_cutadapt cutadapt \
--phred33 --illumina \
--paired \
--three_prime_clip_R1 2 \
--three_prime_clip_R2 2 \
rkatsiteli.leaves.R1.fastq.gz rkatsiteli.leaves.R2.fastq.gz
```
<!--
```bash
trim_galore \
--path_to_cutadapt cutadapt \
--phred33 --illumina \
--paired \
--trim1 \
--clip_R1 20 \
--clip_R2 6 \
--three_prime_clip_R1 4 \
--three_prime_clip_R2 4 \
[file R1.fastq.gz pathway] [file R2.fastq.gz pathway]
```
-->

##### REMEMBER TO REPLACE IT 
{: .success-title }
> STDOUT
>
>311195 sequences processed in total
>
>The length threshold of paired-end sequences gets evaluated later on (in the validation step)
>
>Validate paired-end files rkatsiteli.leaves.R1.teaching_dataset_trimmed.fq.gz and rkatsiteli.leaves.R2_trimmed.fq.gz
>file_1: rkatsiteli.leaves.R1.teaching_dataset_trimmed.fq.gz, file_2: rkatsiteli.leaves.R2.teaching_dataset_trimmed.fq.gz
>
>Now validing the length of the 2 paired-end infiles: rkatsiteli.leaves.R1_trimmed.fq.gz and rkatsiteli.leaves.R2_trimmed.fq.gz
>
>Writing validated paired-end Read 1 reads to rkatsiteli.leaves.R1.teaching_dataset_val_1.fq.gz
>Writing validated paired-end Read 2 reads to rkatsiteli.leaves.R2.teaching_dataset_val_2.fq.gz
>
>Total number of sequences analysed: 311195
>
>Number of sequence pairs removed because at least one read was shorter than the length cutoff (20 bp): 56 (0.02%)
>
>Deleting both intermediate output files rkatsiteli.leaves.R1.teaching_dataset_trimmed.fq.gz and rkatsiteli.leaves.R2.teaching_dataset_trimmed.fq.gz
>
>====================================================================================================

TrimGalore will create different files. Validated reads will be saved in `rkatsiteli.leaves.R1_val_1.fq.gz and rkatsiteli.leaves.R2_val_2.fq.gz` files. Additionally a report is also created separately for `R1` and `R2` files. The report will contain information about the number of sequences removed because of the length of the reads or because of the presence of adapters.


### Perform a second round of quality control on the trimmed data
{: .no_toc }
### Run fastQC on the trimmed files
{: .no_toc }
```bash
fastqc rkatsiteli.leaves.R1_val_1.fq.gz rkatsiteli.leaves.R2_val_2.fq.gz -o rkatsiteli.leaves
```

Open the obtained figures from the output folder in order to evaluate the quality of the processed data. If you compare with the previous results, you should see a slight improvement in the quality of the data. 

---

# 2. Alignment of fastq files and post-processing of the data
Once the raw fastq files have been filtered in order to remove potential contaminants and adapters, we are ready to perform the alignment, given a reference genome.


In order to perform the alignment we will use the Bismark suite [Bismark short manual](https://gabbo89.github.io/EEA2024/docs/2a_Bismark_manual.html){: .btn } [Bismark on github](https://felixkrueger.github.io/Bismark/){: .btn }

<!--
In order to perform the alignment we will use the Bismark suite [^Bismark short manual] [Bismark short manual][bismark short manual] and [^TrimGalore on Github][trimgalore_github].
-->

{: .warning }
> Be sure that the reference genome has the required indexes

We need to create the index files required by Bismark. The reference that we will use is a subset of the original reference. It contains only one chromosome (chr05) and the size is approx. 26.9 Mbp. The file is in fasta format.[^1]


### Copy the reference sequence file to our working directory
{: .no_toc }
```bash
mkdir -p reference # create the reference directory
cp ... /data2/student_space/st24_16_folder/epigenomics/wgbs/reference
```

### Create the indexes required by Bismark (only once)
{: .no_toc }
```bash
bismark_genome_preparation \
--bowtie2 \
--parallel 2 \
--verbose \
/projects/novabreed/share/gmagris/collaboration/lezioni/2024/EEA/wgbs/teaching_dataset/reference
```

####The options used are:

- `--bowtie2` create bisulfite indexes for bowtie2
- `--parallel` define the number of threads for each indexing process (is run already twice in parallel for the **top** and **bottom** strands)
- `--verbose` print a verbose output with more details 
- the last option define the folder containing the reference fasta file. The preparation command should create and additional folder, inside, called `Bisulfite_Genome`

1. bowtie2_folder is the folder containing the bowtie2 software (the command requires the folder name rather the executable).
The folder is:
2. genome_folder is the folder containing the reference fasta file. The preparation command should create and additional folder, inside the `genome_folder`, called `Bisulfite_Genome` > Bisulfite_Genome

{: .success-title }
> STDOUT
>
>Parallel genome indexing complete. Enjoy!
>

The `bismark_genome_preparation` will produce several files in the provided path, into a subfolder called **Bisulfite_Genome**. In the folder you will find the indexes for the reference genome. The indexes are in the format of the bowtie2 indexes.
Now we are ready to perform the reads alignment.


### Perform the paired-end mapping 
{: .no_toc }
USAGE: bismark [options] <genome_folder> {-1 <mates1> -2 <mates2> | <singles>}

```bash
bismark \
--bowtie2 \
--bam \
--phred33-quals \
-N 1 \
-p 2 \
genome_folder \
-1 [file R1.fq.gz pathway] \
-2 [file R2.fq.gz pathway]
```

####The most important options are:
- `--bowtie2 bowtie2` is used as the backend (DEFAULT).
- `--bam` alignment is written in bam format (DEFAULT).
- ../genome genome directory (not entered as a parameter per se, but rather directly in the line).
- `--phred33-quals` Quality format: ASCII chars equal to the Phred quality plus 33 (valid for current Illumina data) (DEFAULT).
- `-N 1` Sets the number of mismatches to be allowed in a seed alignment during multiseed alignment (a bowtie2 property that allows for higher sensitivity).
- `-p 2` Number of cores used for bowtie alignment.
- `-1` read1 file
- `-2` read2 file

The ouput of the aligment process is a `bam file` containing mapping results that can be read using `samtools`.
`Samtools` is a suite of commands that can be used for manipulating sam/bam files. 

Also a .txt file is written together with the report of mapping efficiency that can be read with a normal textual reader command:
For example:
```bash
less -S ...
```

{: .note-title }
>The most important values in the file are:
>
>> Sequences analyzed in total
>
>> Mapping efficiency 
>
>> Number of alignments with a unique best hit from the different alignments 
>
>> Sequences did not map uniquely 


Base on the values it is possible to calculate:

<!--
$$
Total efficiency(%) = (Number of alignments with a unique best hit from the different alignments + sequences did not map uniquely) / Sequences in input
$$

$$ 
\text{Total efficiency(\%)} = \frac{(\text{Number of alignments with a unique best hit from the different alignments} + \text{sequences did not map uniquely})}{\text{Sequences in input}} 
$$

\[
\text{Total efficiency(\%)} = \frac{(\text{Number of alignments with a unique best hit from the different alignments} + \text{sequences did not map uniquely})}{\text{Sequences in input}} \text{ (1)}
\]
-->

> Total efficiency(%) = (Number of alignments with a unique best hit from the different alignments + sequences did not map uniquely) / Sequences in input

<!--
> % methylation (context) = 100 \* methylated Cs (context) / (methylated Cs (context) + unmethylated Cs (context)).
-->

---

# 3. Deduplication and methylome extraction
We need to remove duplicated reads from the alignment file that may have originated from PCR errors.
- add a comment to why duplicated reads need to be removed

### Perform deduplicate
{: .no_toc }
```bash
deduplicate_bismark \
--bam rkatsiteli.leaves.rkatsiteli.leaves.R1_bismark_bt2_pe.bam
```
This will create a filtered bam file with only the reads that passed the deduplication step. 

### Extract methylation information
{: .no_toc }
In order to extract methylation information we will run the command `bismark_methylation_extractor`. The script will operate on Bismark result files and extracts the methylation call for every single C analysed. 

The position of every single C will be written to a new output file, dependending on the context (CG, CHG or CHH), whereby methylated Cs will be labelled as forward read (+) and non-methylated Cs as reverse reads (-). 


```bash
bismark_methylation_extractor \
--genome_folder /projects/novabreed/share/gmagris/collaboration/lezioni/2024/EEA/reference/ \
-p \
--bedGraph \
--cytosine_report \
--CX_context \
--multicore 1 \
--gzip \
rkatsiteli.leaves.rkatsiteli.leaves.R1_bismark_bt2_pe.deduplicated.bam
```

####The most important options are:
- `-p` for processing paired-end data
- `--bedGraph` 
- `--genome-folder`
- `--cytosine_report` 
- `--CX_context` 
- `--multicore` 
- `--gzip` 


{: .success-title }
> STDOUT
>
> Writing genome-wide cytosine report to: rkatsiteli.leaves.rkatsiteli.leaves.R1_bismark_bt2_pe.deduplicated.CX_report.txt.gz
>
> Writing all cytosine context summary file to: rkatsiteli.leaves.rkatsiteli.leaves.R1_bismark_bt2_pe.deduplicated.cytosine_context_summary.txt
>
> Finished writing out cytosine report for covered chromosomes (processed 343 chromosomes/scaffolds in total)
>
> Now processing chromosomes that were not covered by any methylation calls in the coverage file...
>
> Writing cytosine report for not covered chromosome h1tg000079l
> Writing cytosine report for not covered chromosome h1tg000179l
> Finished writing out cytosine report (processed 345 chromosomes/scaffolds in total). coverage2cytosine processing complete.
>
> Finished generating genome-wide cytosine report!


Several files will be produced in this last step. The most important file is the `CX_report.txt` that contain the methylome data.

The files obtained have the following structure.
For example the file `CpG_OT_rkatsiteli.leaves.rkatsiteli.leaves.R1_bismark_bt2_pe.deduplicated.txt.gz` has the following columns:
1. seq-ID
2. methylation state
3. chromosome
4. start position
5. methylation call

Methylated Cs have `+` orientation, while unmethylated Cs have `-`

For example: 

>SEQILMN03:348:CAG91ANXX:8:1101:13304:1989_1:N:0:TGGTGA  +       chr17   13398887        Z
>SEQILMN03:348:CAG91ANXX:8:1101:13304:1989_1:N:0:TGGTGA  +       chr17   13398905        Z
>SEQILMN03:348:CAG91ANXX:8:1101:13304:1989_1:N:0:TGGTGA  +       chr17   13398949        Z
>SEQILMN03:348:CAG91ANXX:8:1101:14588:1992_1:N:0:TGGTGA  +       chr18   34541292        Z
>SEQILMN03:348:CAG91ANXX:8:1101:14588:1992_1:N:0:TGGTGA  +       chr18   34541341        Z
>SEQILMN03:348:CAG91ANXX:8:1101:14588:1992_1:N:0:TGGTGA  +       chr18   34541361        Z
>SEQILMN03:348:CAG91ANXX:8:1101:14588:1992_1:N:0:TGGTGA  +       chr18   34541344        Z
>SEQILMN03:348:CAG91ANXX:8:1101:19965:1990_1:N:0:TGGTGA  -       chr18   35977426        z

It will produce a strand-specific output which will use the following abbreviations in the output file name that indicate the strand the alignment came from:

> OT    - original `TOP` strand
> CTOT  - complementary to original `TOP` strand
> OB    - original `BOTTOM` strand
> CTOB  - complementary to original `BOTTOM` strand

{: .note }
Methylation calls from OT and CTOT will be informative for cytosine methylation positions on the original top strand, calls from OB and CTOB will be informative for cytosine methylation positions on the original bottom strand. Please note that specifying the --directional (the default mode) option in the Bismark alignment step will not report any alignments to the CTOT or CTOB strands.

## BedGraph output
{: .no_toc }
The Bismark methylation extractor can optionally also output a file in bedGraph format which uses 0-based genomic start and 1- based end coordinates. 
The columns are as follows:
1. `chromosome`
2. ``start position``
3. `end position`
4. `value (methylation %)`

Since the methylation percentage is _per se_ not informative of the read coverage at the specific position, a `*.cov.gz` file is also created (1-based genomic coordinates) that feature 2 additional columns:
1. `chromosome`
2. `start position`
3. `end position`
4. `value (methylation %)`
5. `number of methylated Cs`
6. `number of unmethylated Cs`

[link to descriptor](/docs/2a_file_formats.md)
From this file, downstream processing of the file. 

{: .note}
Only performed on CG sites

## M-bias output 
{: .no_toc }
<!--
This allows generating nice graphs by alternative means, e.g. using R or Excel. The plot is also drawn into a .png file which requires the Perl module GD::Graph (more specifically, both modules GD::Graph::lines and GD::Graph::colour are required); if GD::Graph cannot be found on the system, only the table will be printed.
-->
The Bismark methylation extractor can optionally also output a file in M-bias format which uses 0-based genomic start and 1- based end coordinates.?
Methylation bias plot which shows the methylation proportion across each possibile position in the read (cumulatively)[^2]

The output is a tabular file with the following format:
1. `read position`
2. `count methylated`
3. `count unmethylated`
4. `% methylation`
5. `total coverage`



## splitting_report
{: .no_toc }
It represent a summary of the splitting step executed by bismark_methylation_extractor. It the report the % of methylated Cs in the different contexts. 


---

# 4. Manipulating the bam file 
The filtered bam file obtained after deduplicate_bismark, is still unsorted for coordinates.

### sort the bam file 
{: .no_toc }
```bash
samtools sort \
-@ 2 \
-o rkfatsiteli.leaves.bismark_bt2_pe.deduplicated.sort.bam \
rkfatsiteli.leaves.rkatsiteli.leaves.R1_bismark_bt2_pe.deduplicated.bam
```
### index the bam file 
{: .no_toc }
```bash
samtools index -@ 2 rkfatsiteli.leaves.bismark_bt2_pe.deduplicated.sort.bam
```

---

# 5. Conversion rate evaluation 
In order to understand if the conversion rate of the cytosine worked, we need to verify the bisulfite conversion rate. 
We can use the chloroplast genome (or lambda genome)

### Index the chloroplast fasta
{: .no_toc }
```bash
bismark_genome_preparation \
--path_to_aligner /iga/scripts/dev_modules/mambaforge/envs/epigenomics/bin/ \
--bowtie2 \
--parallel 10 \
--verbose \
/projects/novabreed/share/gmagris/collaboration/lezioni/2024/EEA/chloroplast/
```

{: .success-title }
> STDOUT
>
>'========================================='
>
>Parallel genome indexing complete. Enjoy!

Now we are ready to perform the aligment of the reads to the chloroplast genome

### Perform the paired-end mapping
{: .no_toc } 
```bash
bismark \
--bowtie2 \
--bam \
--phred33-quals \
-N 1 \
-p 2 \
genome_folder \
-1 [file R1.fq.gz pathway] \
-2 [file R2.fq.gz pathway]
```

Results are reported in *bismark_bt2_PE_report.txt file!

------

[^1]: [file formats](/docs/2b_file_formats.md). 


[trimgalore short manual]: https://gabbo89.github.io/EEA2024/docs/2a_TrimGalore_manual.html
[trimgalore_github]: https://github.com/FelixKrueger/TrimGalore
[^1]: https://gabbo89.github.io/EEA2024/docs/2a_Bismark_manual.html
<sup>[1]</sup> 


[^2]: https://genomebiology.biomedcentral.com/articles/10.1186/gb-2012-13-10-r83
